# Databricks notebook source
# MAGIC %sh
# MAGIC python  /Workspace/DIFPlatform/QABot_TranscriptCreator/python-client/setup.py install

# COMMAND ----------

# MAGIC %pip install /Workspace/DIFPlatform/QABot_TranscriptCreator/python-client
# MAGIC

# COMMAND ----------

# MAGIC %pip install requests
# MAGIC

# COMMAND ----------

dbutils.library.restartPython()

# COMMAND ----------

import logging
import sys
import requests
import time
import swagger_client
import json


#####################################################

workspaceUrl = spark.conf.get('spark.databricks.workspaceUrl')
print(workspaceUrl)

if '2317951018196210' in workspaceUrl:
  env = 'prod'
elif '440246583814818' in workspaceUrl:
  env = 'hive_metastore'
elif '7386318671908095' in workspaceUrl:
  env = 'dev'
elif '508284401728112' in workspaceUrl:
  env = 'qa'
elif '8490468970670096' in workspaceUrl:
  env = 'stg'
else:
  print('no valid workspace')

print(env)
if env == 'no valid workspace':
    raise ValueError("No valid workspace")

###########################################

dbutils.widgets.text("account_name","usbank")
account_name=dbutils.widgets.get("account_name")

component_name='Audio'

query = f"""
SELECT account_id
FROM {env}_genai_configuration.genai_audit_config.accounts
WHERE lower(accountName) = lower('{account_name}')
"""

result = spark.sql(query).collect()
account_id=result[0]['account_id']

query = f"""
SELECT 
    c.component_id,
    p.timeout_seconds,
    p.parameter_type,
    p.num_workers
FROM 
    {env}_genai_configuration.genai_audit_config.component c
JOIN 
    {env}_genai_configuration.genai_audit_config.parameter p
ON 
    c.component_id = p.ComponentId
WHERE 
    c.component_name = '{component_name}' and p.AccountId = '{account_id}'
"""
df = spark.sql(query)
result = df.collect()[0]
ComponentId = result['component_id']

# Query the table to get the ParameterJson
query = f"""
SELECT ParameterJson
FROM {env}_genai_configuration.genai_audit_config.parameter
WHERE ComponentId = '{ComponentId}' AND AccountId = '{account_id}' and IsEnable='True'
"""

# Execute the query and get the result
parameter_json_df = spark.sql(query)
parameter_json_str = parameter_json_df.collect()[0]['ParameterJson']

# Parse the JSON string into a dictionary
parameters = json.loads(parameter_json_str)
print(parameters)

scriptpath = parameters['scriptpath']
audiopath=parameters['audiopath']
scope = parameters['scope']

##################################################

scriptpath = dbutils.secrets.get(scope, key=scriptpath)
audiopath=dbutils.secrets.get(scope, key=audiopath) 

logging.basicConfig(stream=sys.stdout, level=logging.DEBUG,
        format="%(asctime)s %(message)s", datefmt="%m/%d/%Y %I:%M:%S %p %Z")

# Your subscription key and region for the speech service
SUBSCRIPTION_KEY = "8e0fb1a3ca4e4916a2fed314d9de2b24"
SERVICE_REGION = "eastus"

NAME = "voice_to_text"
DESCRIPTION = "voice to text description"

LOCALE = "en-US"
RECORDINGS_CONTAINER_URI =audiopath

# Set model information when doing transcription with custom models
MODEL_REFERENCE = None  # guid of a custom model

def transcribe_from_single_blob(uri, properties):
    """
    Transcribe a single audio file located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_urls=[uri],
        properties=properties
    )

    return transcription_definition

def transcribe_with_custom_model(client, uri, properties):
    """
    Transcribe a single audio file located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    # Model information (ADAPTED_ACOUSTIC_ID and ADAPTED_LANGUAGE_ID) must be set above.
    if MODEL_REFERENCE is None:
        logging.error("Custom model ids must be set when using custom models")
        sys.exit()

    model = {'self': f'{client.configuration.host}/models/{MODEL_REFERENCE}'}

    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_urls=[uri],
        model=model,
        properties=properties
    )

    return transcription_definition


def transcribe_from_container(uri, properties):
    """
    Transcribe all files in the container located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_container_url=uri,
        properties=properties
    )

    return transcription_definition


def _paginate(api, paginated_object):
    """
    The autogenerated client does not support pagination. This function returns a generator over
    all items of the array that the paginated object `paginated_object` is part of.
    """
    yield from paginated_object.values
    typename = type(paginated_object).__name__
    auth_settings = ["api_key"]
    while paginated_object.next_link:
        link = paginated_object.next_link[len(api.api_client.configuration.host):]
        paginated_object, status, headers = api.api_client.call_api(link, "GET",
            response_type=typename, auth_settings=auth_settings)

        if status == 200:
            yield from paginated_object.values
        else:
            raise Exception(f"could not receive paginated data: status {status}")


def delete_all_transcriptions(api):
    """
    Delete all transcriptions associated with your speech resource.
    """
    logging.info("Deleting all existing completed transcriptions.")

    # get all transcriptions for the subscription
    transcriptions = list(_paginate(api, api.get_transcriptions()))

    # Delete all pre-existing completed transcriptions.
    # If transcriptions are still running or not started, they will not be deleted.
    for transcription in transcriptions:
        transcription_id = transcription._self.split('/')[-1]
        logging.debug(f"Deleting transcription with id {transcription_id}")
        try:
            api.delete_transcription(transcription_id)
        except swagger_client.rest.ApiException as exc:
            logging.error(f"Could not delete transcription {transcription_id}: {exc}")


def transcribe():
    logging.info("Starting transcription client...")

    # configure API key authorization: subscription_key
    configuration = swagger_client.Configuration()
    configuration.api_key["Ocp-Apim-Subscription-Key"] = SUBSCRIPTION_KEY
    configuration.host = f"https://{SERVICE_REGION}.api.cognitive.microsoft.com/speechtotext/v3.2"

    # create the client object and authenticate
    client = swagger_client.ApiClient(configuration)

    # create an instance of the transcription api class
    api = swagger_client.CustomSpeechTranscriptionsApi(api_client=client)
    # Specify transcription properties by passing a dict to the properties parameter.    
    properties = swagger_client.TranscriptionProperties()
    #Visharad: script as of now go ahead. Need to think in future.
    properties.destination_container_url = scriptpath
    #vish
    transcription_definition = transcribe_from_container(RECORDINGS_CONTAINER_URI, properties)
    created_transcription, status, headers = api.transcriptions_create_with_http_info(transcription=transcription_definition)
    # get the transcription Id from the location URI
    transcription_id = headers["location"].split("/")[-1]
    # Log information about the created transcription. If you should ask for support, please
    # include this information.
    logging.info(f"Created new transcription with id '{transcription_id}' in region {SERVICE_REGION}")
    logging.info("Checking status.")

    completed = False

    while not completed:
        # wait for 5 seconds before refreshing the transcription status
        time.sleep(5)

        transcription = api.transcriptions_get(transcription_id)
        logging.info(f"Transcriptions status: {transcription.status}")

        if transcription.status in ("Failed", "Succeeded"):
            completed = True

        if transcription.status == "Succeeded":
            if properties.destination_container_url is not None:
                logging.info("Transcription succeeded. Results are located in your Azure Blob Storage.")
                break

            pag_files = api.transcriptions_list_files(transcription_id)
            for file_data in _paginate(api, pag_files):
                if file_data.kind != "Transcription":
                    continue

                audiofilename = file_data.name
                results_url = file_data.links.content_url
                results = requests.get(results_url)
                logging.info(f"Results for {audiofilename}:\n{results.content.decode('utf-8')}")
        elif transcription.status == "Failed":
            logging.info(f"Transcription failed: {transcription.properties.error.message}")


if __name__ == "__main__":
    transcribe()
